---
title: iOS 实现RSA公钥解密
categories: [RSA]
---

对于RSA加解密来说，一般就是公钥加密、私钥解密；或者私钥加密、公钥验签。并且在iOS的API中同样也是提供了这两种形式的方法。

> SecKeyEncrypt（加密）  
  SecKeyDecrypt（解密）  
  SecKeyRawVerify（验签）  


但是在做RSA加密的时候，客户端保存的只会有一个公钥，有些时候会需要进行公钥解密。后来查了一些资料最后还是找到了解决方案：通过 openssl 来实现。

>RSA_public_encrypt  
RSA_private_encrypt  
RSA_public_decrypt  
RSA_private_decrypt  


**更新： 在后面的深入了解之后发现，其实iOS原生也能做私钥加密和公钥加密。**  

iOS原生的两个方法其实说的是加密和解密，并没有指定是用那个密钥做加解密。先大致看下RSA加解密的原理：

##### 1.密钥组成  

公钥 (E,N)   
私钥 (E,D,N)

关于每个数是怎么来的这里不介绍，感兴趣的可以自己查一下，这里只做加解密的原理解释。  

##### 2.加解密原理  
现在已经有了密钥对，那再看下加解密的过程  

密文 = 明文<sup>E</sup>  mod N  
明文 = 密文<sup>D</sup>  mod N

我们通过一个具体的例子来直观体验下，经过计算我们现在得到一对具体的密钥对：

公钥=(E，N) = (5，323)  
私钥=(D，N) = (29，323)  

B = A<sup>E</sup>  mod N = pow(123, 5) % 323 = 225  
A = B<sup>D</sup>  mod N = pow(225, 29) % 323 = 123  

**如果 A(123) 为明文，那上面的过程就是 公钥加密私钥解密;**  
**如果 B(225) 为明文，那上面的过程就是 私钥加密公钥解密;**  

换一下顺序可能会更清除一点:    
A = B<sup>D</sup>  mod N = pow(225, 29) % 323 = 123 (私钥加密)   
B = A<sup>E</sup>  mod N = pow(123, 5) % 323 = 225 (公钥解密)  

这样一来我们就会发现，其实加解密是同一个方法。那为什么会有加密和解密两个方法呢？我的理解是：

加密就是，传入数据直接做计算（就像上面的那样）  
解密就是，传入数据直接做计算（还是上面的那样），不过会根据填充模式做数据处理，把填充的随机数剔除掉。


##### 3.填充格式
一般最常用的是 PKCS1。这个填充格式会要求每次加密的数据比密钥长度短11个字节(keySize - 11)，输出长度跟密钥长度一致

```
PS 为随机填充数，M为明文

00 02 | PS | 00 | M     (公钥加密)
00 01 | PS | 00 | M     (私钥加密)
```

还有一个是None就是不填充。这个的密文长度可以跟密钥一样长，但是如果比密钥短的话会在明文的前面填充零(0)

```
0000 | M
```

|填充方式|最大输入长度|输出长度|填充内容|
|:-:|:-:|:-:|:-:|
|PKCS1| keySize - 11 | keySize | 随机数|
|none | keySize | keySize | 00|

##### 4.公钥解密

现在知道了加密的原理和填充方式，那试一下

```c
- (NSData * )decryptWithPublicKey:(SecKeyRef)publicKeyRef cipherData:(NSData * )cipherData {

    size_t keySize = SecKeyGetBlockSize(publicKeyRef) * sizeof(uint8_t);
    double totalLength = [cipherData length];
    size_t blockSize = keySize;
    int blockCount = ceil(totalLength / blockSize);
    NSMutableData * plainData = [NSMutableData data];
    for (int i = 0; i < blockCount; i++) {
        NSUInteger loc = i * blockSize;
        long dataSegmentRealSize = MIN(blockSize, totalLength - loc);
        NSData * dataSegment = [cipherData subdataWithRange:NSMakeRange(loc, dataSegmentRealSize)];
        unsigned char * plainBuffer = malloc(keySize);
        memset(plainBuffer, 0, keySize);
        OSStatus status = noErr;
        size_t plainBufferSize ;
        status = SecKeyDecrypt(publicKeyRef,
                               kSecPaddingNone, // 解密的时候一定要用 无填充模式，拿到所有的数据自行解析
                               [dataSegment bytes],
                               dataSegmentRealSize,
                               plainBuffer,
                               &plainBufferSize
                               );
        if(status != noErr){
            free(plainBuffer);
            return nil;
        }

        NSData * data = [[NSData alloc] initWithBytes:plainBuffer length:plainBufferSize];

        NSData * startData = [data subdataWithRange:NSMakeRange(0, 1)];
        // 开头应该是 0001 但是原生解出来之后把开头的 00 忽略了
        if ([[startData description] isEqualToString:@"<01>"]) {
            Byte flag[] = {0x00};
            NSRange startRange = [data rangeOfData:[NSData dataWithBytes:flag length:1] options:NSDataSearchBackwards range:NSMakeRange(0, data.length)];
            NSUInteger s = startRange.location + startRange.length;
            if (startRange.location != NSNotFound && s < data.length) {
                data = [data subdataWithRange:NSMakeRange(s, data.length - s)];
            }
        }

        [plainData appendData:data];
        free(plainBuffer);
    }

    return plainData;
}
```

这里有几个需要注意的点  
1、 填充方式一定要为kSecPaddingNone，因为我们不希望系统帮我们做数据的截取，默认解出来的所有数据都是我们需要的  
2、当加密的填充模式为PKCS1 ，理乱上开头应该是 0001 的，但是NSData 会把开头的 00 忽略掉。所以开头就成了01。  
3、 当加密的填充模式为None， 理乱上填充的应该都是 0 的，同样NSData 会把开头的 00 忽略掉，所以解出来的就是真实的数据不用处理。  

##### 5.私钥加密
既然说到公钥解密就顺便说一下私钥加密，原生这个并没有这几的私钥解密，即使传入私钥使用解密的方法也不行。但是可以通过另外一条思路来实现。  

在上面的原理介绍中提到加密解密其实用的是同一个方法，所以我们可以使用解密的方法来进行加密。实验证明是可以的。  
**但是要注意一点填充模式要设置为kSecPaddingNone。因为这个毕竟是一个解密的方法，如果不用kSecPaddingNone内部会做数据的处理，但是这并不是我们需要的，我们需要的是完整的数据。**

使用openssl的私钥加密是要注意：当填充模式为 RSA_NO_PADDING 时，如果明文长度小于密钥长度则加密会失败。


更详细的东西可以看[Demo](https://github.com/DullDevil/RSADemo)。
