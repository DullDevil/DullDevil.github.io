---
title: iOS 面试题
---

### 语言基础

#### 类与元类有什么区别
>关键词：objc_class 指针、继承关系

Objective-C 作为一门面向对象的编程语言，对象是基本的构造单元。内存布局以一个  objc_class （Class） 指针为开始的所有数据都可以当做一个 object 来对待。

所以说类（Class）也是对象，称为类对象（Class Object），一般的实例称为实例对象（Instance Object）。对象的isa指针指向对象所属的类，类中存储这对象所有的特性，比如方法列表、属性列表等。类对象所属的类被称为元类（Mate Class）。


获取一个对象所属的类，会用到 `[self class]`。如果self为实例，那返回的就是self 所属的类，如果self为类对象，则返回的是self本身。

如果想要获取到类对象所属的元类需要用到`object_getclass(self)`
如果self为实例对象，返回的就是self所属的类，跟`[self class]`效果一样。如果self为类对象，则返回的就是类对象所属的元类。

类使用 super_class 指针指向自己的父类， 元类的 super_class 会指向类的 super_class 的元类 。一直追溯到基类的 meta-class ，它的 super_class 会指向基类自身。  



#### @property 的本质是什么

>关键词：自动合成、编译时、@synthesize、@dynamic

“属性” (property)有两大概念：ivar（实例变量）、存取方法（access method ＝ getter + setter）。

完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”(autosynthesis)。

@property有两个对应的词，一个是 @synthesize，一个是 @dynamic。如果 @synthesize 和 @dynamic 都没写，那么默认的就是 @syntheszie var = _var; 

当你想手动管理  @property  的所有内容时，你就会尝试通过实现  @property  的所有“存取方法”（the accessor methods）或者使用  @dynamic  来达到这个目的，这时编译器就会认为你打算手动管理 @property，于是编译器就禁用了 autosynthesis （自动合成）。



#### 属性的描述关键词有哪些？

内存管理：retain、copy、strong、weak、unsafe_unretained、assign
线程安全：atomic、nonatomic
访问权限：readonly、readwrite
变量名称：getter、setter



#### 类别中为什么不能直接添加属性

> 关键词：运行时、编译后、成员变量、对象关联、

类别的作用用来：分散类的实现、向现有的类中添加方法、添加私有方法。

category是运行时才被合并到所属的类中的，编译后的类已经注册在 runtime 中，类结构体中的  objc_ivar_list  实例变量的链表 和  instance_size 实例变量的内存大小已经确定，同时runtime 会调用  class_setIvarLayout  或  class_setWeakIvarLayout 来处理 strong weak 引用。所以不能再添加成员变量。也正是这个原因在类别的结构中，没有存储成员变量的数据结构。

在类别中使用@property声明属性时，只会生成对应的setter和getter方法的声明，不会生成实例变量，也不会setter 与 getter 方法的实现。

在category里面是无法为category添加实例变量的。但是可以通过关联对象的方式，为对象关联一个值。

所有的关联对象都由AssociationsManager管理，AssociationsManager里面是由一个静态AssociationsHashMap来存储所有的关联对象的。这相当于把所有对象的关联对象都存在一个全局map里面。而map的的key是这个对象的指针地址（任意两个不同对象的指针地址一定是不同的），而这个map的value又是另外一个AssociationsHashMap，里面保存了关联对象的键值对。

跟类别相比，有一个比较相似的特性：扩展（extension）。extension在编译期决议，它就是类的一部分。category则完全不一样，它是在运行期决议的。



#### 类别中的方法名如果跟类中的方法同名，会执行哪个

> 关键词：运行时合并、方法查找方式

如果类别中的方法名如果跟类中的方法同名，调用的时候会执行类别中实现的方法。

在程序运行的时候，通过Runtime加载某个类的所有Category数据，同时将Category中的方法、属性、协议数据合并到一个大数组中。

将合并后的类别数据包括方法、属性、协议等信息，插入到类原来数据的前面。如果有相同的方法名，则数组中就会存在两个相同的方法名，并不会覆盖掉原有的方法。但是在调用的时候，一旦找到需要的方法名，就会停止查询。所以会造成方法被覆盖的现象。

如果有多个类别文件，类别的加载顺序跟 compile sources 中文件的顺序有关。在后面的参与编译的文件同样会覆盖前面的类别方法。

这里的覆盖，并不是完全替换掉原来类的同名方法，当类和类别中有相同的方法名的时候，在方法列表中就会有两个相同的方法名，只是category在方法列表的前面而已。运行时在查找方法的时候是顺着方法列表的顺序查找的，它只要一找到对应名字的方法，就会停止，所以后面注册进来的方法就不会执行到。



#### 执行一个空的Block时，程序为什么是会崩溃

> 关键词：对象、偏移获取函数体

Block本质也是一个对象，以isa指针开头的结构体。执行Block就是调用一个以Block自身作为参数的函数，这个函数对应着Block的执行体。

执行 Block 时，会通过Block指针找到相应的函数（Block内容）进行调用。如果Block为空，程序运行的时候，就会从0x0的位置向后偏移一定的字节来获取函数体，这时就会获取一个错误的函数地址，导致调用函数出错。



#### Block为什么不能修改外部的局部变量？

> 关键词：值传递、指针不同、执行时环境

Block可以修改它被调用时所处作用域内的变量。比如全局变量、Block作为成员变量时可以访问同一个对象里的其它成员变量。

对于局部变量，如果是基本数据类型，则进行的时值传递，所以不能修改。如果是指针类型，为了保证访问数据的安全，Block会在堆上重新创建一个指针，指向与外部变量相同的内存地址。换句话说，声明的外部变量指针，跟Block中使用的变量指针是两个不同的指针，所以给Block内的指针重新赋值是不会影响Block外的指针的。

`__Block`修饰之后，外部变量会被包装成 `__Block_byref_i_0` 的结构体，当被Block引用之后，同时会在堆上创建一个新的指针，并且两个指针指向的内容，也就是说两个指针都指向同一个变量，所以Block内就能修改Block外的变量了。



#### Block为什么要用`copy`

因为Block变量默认是声明为栈变量的，为了能够在Block的声明域外使用，所以要把Block拷贝（copy）到堆。Block的retain内部也是copy操作，所以说两者是等价的，并且在arc下，block默认都会被copy到堆上。



#### Block 为什么会引起循环引用

Block为了防止引用的外部变量提前释放，所以会对引用的对象做一次reatin操作。



#### 方法交换的原理

> 关键词：selector、IMP

方法列表会把选择子（selector）的名字映射到相关的方法实现上，使得“动态消息转发系统”能够据此找到应该调用的方法。方法实现以函数指针的形式来表示，这种指针叫做 IMP。选择子（selector）与 IMP 的是一一映射的关系，方法交换其本质就是修改两者的映射关系。




#### 运行时的简单理解

因为Objective-C是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个 Objective-C 运行框架的一块基石。

一般说到Objective-C的Runtime，指的是runtime库，这个库提供了查询、修改运行时环境的功能。常用的操作有：

1. 查询对象的属性列表，常用的就是实现JSON转Model的实现。

2. 查询对象的继承关系，确定动态类型。

3. 修改方法实现，可用来实现AOP埋点、修改系统方法等

4. 对象关联，可用来实现给类别添加属性的需求。

   

#### 消息机制的简单流程

>关键词：消息传递、消息转发、缓存

Objective-C 中方法的调用称为：消息传递。通过objc_msgSend方法向一个对象发送一个包含方法名（SEL）的消息，对象收到消息之后，在自己的方法列表中查找SEL对应的函数（method_imp），如果找到就执行相应的函数，如果没找到就到父类的方法列表中查找，一直到顶级父类（NSObject），如果都没找到就会进入消息转发阶段。消息转发分为三个步骤：动态方法解析、备用接收者、完整消息转发。如果消息转发也没有处理这条消息，方法调用就失败了，系统就会抛出异常。

为了保证消息发送与执行的效率，系统会将全部selector和使用过的方法的内存地址缓存起来。每个类都有一个独立的缓存，缓存包含有当前类自己的 selector以及继承自父类的selector。查找调度表（dispatch table）前，消息发送系统首先检查receiver对象的缓存。



#### self 与 super 的区别

>关键词：直接找父类

self 是类的隐藏参数，指向当前调用方法的这个类的实例。  

super 是一个 Magic Keyword， 它本质是一个编译器标示符，和 self 是指向的同一个消息接受者！他们两个的不同点在于：super 会告诉编译器，调用 class 这个方法时，要去父类的方法，而不是本类里的。  

不管调用`[self class]`还是`[super class]`，接受消息的对象都是当前这个对象。    
当使用 self 调用方法时，会从当前类的方法列表中开始找，如果没有，就从父类中再找；而当使用 super 时，则从父类的方法列表中开始找。然后调用父类的这个方法。



#### 动态特性包含哪些

> 关键词：动态类型、动态绑定、动态加载

动态类型：运行时再决定对象的类型。这类动态特性在日常应用中非常常见，简单说就是id类型。对象的类型确定推迟到运行时，由赋给它的对象类型决定对象指针的类型。

动态绑定：指的是方法确定的动态性。动态绑定是基于动态类型的，在运行时对象的类型确定后，那么对象的属性和方法也就确定了(包括类中原来的属性和方法以及运行时动态新加入的属性和方法)。一个OC对象是否调用某个方法不是由编译器决定的，而是由运行时决定的；另外关于动态绑定的关键一点是基于消息传递机制的消息转发机制，主要处理应对一些接受者无法处理的消息，此时有机会将消息转发给其他接收者处理。

动态加载主要包括两个方面，一个是动态资源加载，一个是一些可执行代码模块的加载，这些资源在运行时根据需要动态的选择性的加入到程序中，是一种代码和资源的‘懒加载’模式，可以降低内存需求，提高整个程序的性能，另外也大大提高了可扩展性。



#### 内存管理的方式

> 关键词：引用计数、ARC/MRC

Objective-C 使用用引用计数的方式进行内存管理。当内存块的引用计数为0时，对用的内存区域会被释放掉。

对象的引用计数是存放在对象的isa指针中。isa在OBJC2中是一个经过优化的指针不单存放着类对象的地址还存放着其他有用的信息，其中就包括引用计数信息的存储。

在 iOS5 之前采用 MRC的方式管理引用计数，需要在编程的过程中手动加入 retain/release；从 iOS5 之后开始使用 ARC的方式管理引用计数，系统会在适当的位置自动插入 retain/release；

#### 常见的内存泄漏有哪些

1、**循环引用**：两个及以上对象相互引用导致不能正常的释放。比如：

1. 属性引起的循环引，这种情况可以通过修改属性描述来解决，将 strong 关系改为 weak 关系。
2. Block会对内部使用的对象进行强引用，如果内部引用的对象对Block也有强引用，就会形成循环引用。可以用到 __weak 修饰符破除引用环。
3. NSTimer 会强引用 target，并且Timer并不会主动停止，如果targer也强引用了Timer就会引起循环引用。可创建一个中间对象，弱引用self，同时Timer引用了中间对象，这样通过弱引用来解决了相互引用。

2、**非OC类API**：ARC 只对OC类的对象生效，如果调用非OC类的API仍需要手动管理内存。

3、**performSelector**：当调用 performSelector 方法是，系统并不确定方法的返回值是否需要释放，所以为了安全起见，系统并不会插入 release 方法，如果 performSelector 调用了一个增加引用计数的方法就会造成内存泄漏。

#### weak 变量时如何实现自动置nil的

Runtime维护了一个weak表，用于存储指向某个对象的所有weak指针。weak表其实是一个hash（哈希）表，Key是所指对象的地址，Value是weak指针的地址（这个地址的值是所指对象的地址）数组。当对象释放时找到对应的数组，将所有的指针指向nil。



#### Autorelease Pool是如何工作的

> 关键词：Runloop、`objc_autoreleasePoolPop`

NSAutoreleasePool是对象引用计数自动处理器，ARC下，我们使用`@autoreleasepool{}`来使用一个Autorelease Pool，本质上是添加`objc_autoreleasePoolPush`和`objc_autoreleasePoolPop`。

在MRC下当对象调用`autorelease`时，对象被被放进Autorelease Pool中，当Autorelease Pool释放时，会向Autorelease Pool中的所有对象发送`release`消息。

在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的Runloop迭代结束时释放的，而它能够释放的原因是**系统在每个Runloop迭代中都加入了自动释放池Push和Pop**。对于手动添加的Autorelease Pool，在大括号结束时释放，也就是在代码块儿的结尾会调用`objc_autoreleasePoolPop`。

如果编写的循环中创建了大量的临时对象，可以使用 `@autoreleasepool{}`来提前释放临时变量，以到达内存优化的效果。

#### RunLoop和线程的关系

> 关键词：持续运行、按需分配、一一对应

RunLoop实际上是一个对象，这个对象在循环中用来处理程序运行过程中出现的各种事件（比如说触摸事件、UI刷新事件、定时器事件、Selector事件），从而保持程序的持续运行；而且在没有事件处理的时候，会进入睡眠模式，从而节省CPU资源，提高程序性能。

一条线程对应一个RunLoop对象，每条线程都有唯一一个与之对应的RunLoop对象，RunLoop能够保证线程能够持续运行。在子线程创建Runloop，不是通过alloc init方法创建，而是直接通过调用`currentRunLoop`方法来创建，它本身是一个懒加载的。



#### 与RunLoop相关的注意事项

1、NSTimer 与 滑动的冲突

在开启一个NSTimer实质上是在当前的runloop中注册了一个新的事件源，而当scrollView滚动的时候，当前的 MainRunLoop是处于UITrackingRunLoopMode的模式下，在这个模式下，是不会处理NSDefaultRunLoopMode 的消息(因为RunLoop Mode不一样)，要想在scrollView滚动的同时也接受其它runloop的消息，我们需要改变两者之间的runloopmode.

2、使用RunLoop实现的定时器不够精准

一个 Timer 注册到 RunLoop 后，RunLoop 会为其重复的时间点注册好事件。RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。

#### 创建计时器的几种方式

依赖Runloop不够精准：NSTimer、CADisplayLink

依赖于内核精准：GCD

注意事项**:** 下面两种操作会造成程序崩溃**,** 原因是**: gcdTimer**执行了**suspend()**操作后**,** 是不可以被直接释放的**,** 如果想关闭一个执行了**suspend()**操作的计时器**,** 需要先执行**resume(),** 再执行**cancel(),** 最后置**nil.**

```
// 崩溃一:
gcdTimer?.suspend()
gcdTimer = nil
// 崩溃二: 
gcdTimer?.suspend()
gcdTimer?.cancel()
gcdTimer = nil
```



#### KVO的实现原理

利用Runtime动态生成一个中间类，将原类的isa指向生成的对象。然后重写Setter和Getter方法，以实现对属性值变化的监听。



#### NSCoding协议是干什么用的？

归档时和解档时需要依赖该协议定义的编码和解码方法。

一般被NSKeyedArchiver做自定义对象持久化时使用。

需要实现两个方法

```
- (instancetype)initWithCoder:(NSCoder *)aDecoder;
- (void)encodeWithCoder:(NSCoder *)aCoder;
```

#### **iOS** 程序内容加载顺序

1. 启动 dyld，将二进制文件初始化

2. ImageLoader 把二进制文件加载进内存

3. runtime 执行 load_images ，执行所有的 load 方法。

4. 执行自定义的 load 方法

#### load 与initialize的调用时机

加载阶段，如果类实现了load方法，系统就会调用它，load方法不参与覆写机制。附加category到类的工作会先于`+load`方法的执行，所以可以在load方法中调用分类中的方法。

在首次使用某个类之前，系统会向其发送initialize消息，通常应该在里面判断当前要初始化的类，防止子类未覆写initialize的情况下调用两次

#### @class和import以及include的区别

import会引入整个.h头文件。

@class只是告诉编译器该类中可以使用这个class类名。

include和import的作用类似，但是可能造成重复引用的问题。一般用判断宏定义是否存在的方式来防止循环引用。



### 多线程

#### 同步/异步、串行/并发

同步：针对于任务而言的概念，阻塞当前线程，不执行结束，当前线程就不会继续往下执行。

异步：针对于任务而言的概念，不阻塞当前线程，当前线程会继续往下执行。

串行：针对于队列而言，串行队列遵守FIFO(first-in-first-out)原则，只能一个任务一个任务地顺序执行。

并发：针对于队列而言，并发队列可以在同一时间执行多个任务。

#### GCD线程锁死是如何产生的

在串行队列的任务中，向所在的队列添加同步任务操作，就会出现线程锁死的情况。

#### GCD常用API

**`dispatch_semaphore`（信号量）**：通常是用来多线程执行多个并发任务时通过信号量的方式对并发执行数量的限制。当信号量不够(=0)的时候当前调用线程将被阻塞，所以我们可以通过模拟信号量不够的情况来阻塞同步方法的返回，直到方法内部的异步回调之后；

**`dispatch group`**：通常用于处理多个任务结束后，再处理某一任务。`dispatch_group_enter`和`dispatch_group_leave`必须成对出现。

**`dispatch source`**：通常用于实现定时器。使用时有几个注意点：循环引用、重复调用`dispatch_resume`会崩溃、suspend状态下不能直接释放timer。

**`dispatch_after`**：延迟操作。并不是在指定时间后执行处理，而是在指定时间追加任务到指定的队列

**`dispatch barrier`**：以barrier为分界, 前面的执行完才能执行后面的。



#### NSOperation有哪些特性，比着GCD有哪些优点

NSOperation是对GCD的封装，具有面向对象的特点，可以更方便的进行封装，可以设置依赖关系、最大线程并发数、线程的优先级。

NSOperation 已支持异步操作之间的事务性，顺序行，依赖关系。GCD则需要写大量的代码来实现

GCD更接近底层，效率更高。

GCD是用C语言实现的，而NSOperation是用OC实现的。



### GUI

#### 离屏渲染是什么，为什么会引起卡顿

离屏渲染就是某些渲染不能在当前屏幕上下文中处理，需要单独开出一块内存进行渲染，处理完后再输出到当前屏幕的上下文。卡顿主要是因为上下文的创建和切换导致了性能的丢失。

会引起离屏渲染的场景：cornerRadius+clipsToBounds、shadow、group opacity、mask、UIBlurEffect



### 网络

#### 网络请求的七层协议

应用层 - 会话层 - 表示层- 传输层 -网络层 - 数据链路层 - 物理层



### 设计模式

#### 跨组件通信的方式

NSNotification： 是同步发送消息的，适用于毫无关联的页面之间或者系统消息的传递，属于一对多的信息传递关系。如果在子线程中发送通知，则接受也是在子线程中。

KVO：监听对象的某一属性值的变化状况，当需要监听对象属性改变的时候使用。

代理： 一对一的信息传递方式，适用于相互关联的页面之间的信息传递。





