---
title: iOS RSA密钥的生成与转换
categories: [RSA]
---

RSA加密需要用到密钥对，也即是公钥和私钥。对于iOS生成RSA密钥对来说，有两种选择，一种是通过系统原生的方法来生成，另一种是借助第三方库比如openssl。

### iOS 原生生成密钥对（方法一）
系统提供了一系列关于RSA加解密和签名验签的方法，同时也提供了生成密钥对的方法

```objective_c
OSStatus SecKeyGeneratePair(CFDictionaryRef parameters, SecKeyRef * _Nullable CF_RETURNS_RETAINED publicKey,
    SecKeyRef * _Nullable CF_RETURNS_RETAINED privateKey) __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_2_0);
```
这样生成的密钥是`SecKeyRef`格式的，有时候可能会需要将生成的公钥提给其他人使用，就需要将密钥进行格式转换，最常见的就是转换成字符串的形式。幸运的是我们也可是通过一定的方式将`SecKeyRef` 转换为 `NSData`，然后再转化成base64类型的字符串。

### openssl 生成密钥对（方法二）
openssl 也提供了生成密钥对的方法，这种方法不不像iOS系统提供的方法是直接生成了公钥和私钥，而是先生成了一个`RSA`然后通过方法提取公钥和私钥。

```objective_c
// 生成密钥对
/* Deprecated version */
# ifndef OPENSSL_NO_DEPRECATED
RSA *RSA_generate_key(int bits, unsigned long e, void
                       (*callback) (int, int, void *), void *cb_arg);
# endif                         /* !defined(OPENSSL_NO_DEPRECATED) */

/* New version */
int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);

//提取公钥、私钥
RSA *RSAPublicKey_dup(RSA *rsa);
RSA *RSAPrivateKey_dup(RSA *rsa);
```

同样的问题，当需要把生成的公钥分发出去的时候，就需要将密钥转换成字符串类型。类型转换可以用到`pem.h`，先将密钥信息写入pem文件，然后获取pem文件的内容，这样就得到了pem格式的字符串。

```objective_c
- (NSString *)PEMFormatPublicKey:(RSA *)rsaPublic
{
    BIO *bio = BIO_new(BIO_s_mem());
    PEM_write_bio_RSA_PUBKEY(bio, rsaPublic);

    BUF_MEM *bptr;
    BIO_get_mem_ptr(bio, &bptr);
    BIO_set_close(bio, BIO_NOCLOSE); /* So BIO_free() leaves BUF_MEM alone */
    BIO_free(bio);

    return [NSString stringWithUTF8String:bptr->data];
}

```

pem格式的公钥

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAz+paaDqx9RoXuI5MIUcf
/nXGYBNAd9GcwqvBxZYrsssnXQ9L9VF7omh8x8JqEZizTbgXHFCnIYqRGYwZQR33
AH0cVwR/oajX9oQIHJPaR8PbXBs51xdNXILd5UFqShI8IeUT7jRex5huzMvpHOvy
vsAzsbHPf6anvtF4L6glnpEF1fCC0aNFCdDPXooZgLyQHm8qZs8SuXMjWtcV5B76
zrD39uNvb0YLRkhI8ixVMaF97nq690LnqSfsvmhFnQ1fXQE0KqalliXTu/K5RFHi
mOWEQwLS1D4AXUyq2vZI3BzCqU4jJvPQPN51A3KI00uh43xAPvbOsmVYcFBILwjv
GwIDAQAB
-----END PUBLIC KEY-----
```
---
### 两种方法生成字符串的区别
两种方案生成的密钥其实就是编码方式不同而已，方案一生成的是cer格式的密钥（0x30开头），方案二生成的是PEM格式的密钥（对cer格式的再次封装）但是主要的信息都是有的，只是不同的格式要做不同的解析处理。


### 问题如何解决
其实对应公钥来说最主要的就是指数和模数，只要有了这两个信息就能进行RSA的加解密操作。并且openssl也提供了通过指数和模数生成公钥的方法，iOS原生系统下也可以通过数据处理将指数和模数生成`SecKeyRef`。

openssl不仅提供了通过指数和模数生成密钥的方法，同时也有生成RSA密钥对，RSA加解密的方法，并且提供了许多原生系统不支持的方法，比如公钥解密。所以，如果需要动态生成密钥对，并且需要把密钥提供给其他平台使用的情况还是选择使用openssl会方便许多。当然，如果只是最数据加解密，或者生成的密钥也是给iOS／OS X平台使用的，那用原生的方式也是可以的。

---
### 代码示例
写了个[Demo](https://github.com/DullDevil/RSADemo)，包含了密钥的生成（openssl、SecKeyRef，指数模数生成公钥）、密钥类型的转换（RSA转PEM，PEM转RSA，PEM转SecKeyRef，SecKeyRef转NSData）、指数模数的读取以及分段加密解密。
如果对你有帮助可以给个start，如果有什么错误或不足也请在评论区指出。

---

同时相关的文章也放下面：
[RSA公钥文件（PEM）解析](http://blog.csdn.net/xuanshao_/article/details/51679824)
[ios 中 使用mod和exp生成公钥(.cer)](http://blog.csdn.net/show3/article/details/43735619)
[RSA加密](https://blog.cnbluebox.com/blog/2014/03/19/rsajia-mi/)
