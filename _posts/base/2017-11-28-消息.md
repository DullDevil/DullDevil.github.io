---
title: iOS 基础：消息
categories: [根深柢固]
---

- TOC
{:toc}


## Runtime介绍
作为一门动态编程语言，Objective-C 会尽可能的将编译和链接时要做的事情推迟到运行时。只要有可能,Objective-C 总是使用动态的方式来解决问题。这意味着 Objective-C 语言不仅需要一个编译环境,同时也需要一个运行时系统来执行编译好的代码。运行时系统（runtime）扮演的角色类似于 Objective-C 语言的操作系统,Objective-C 基于该系统来工作。了解 Runtime ，要先了解它的核心 - 消息传递 （Messaging）。


Runtime 基本是用 C 和汇编写的。高级编程语言想要成为可执行文件需要先编译为汇编语言再汇编为机器语言，机器语言也是计算机能够识别的唯一语言，但是OC并不能直接编译为汇编语言，而是要先转写为纯C语言再进行编译和汇编的操作，从OC到C语言的过渡就是由runtime来实现的。然而我们使用OC进行面向对象开发，而C语言更多的是面向过程开发，这就需要将面向对象的类转变为面向过程的结构体。


## 发送消息
在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说这叫做“传递消息”（pass a message）。消息有名称（name）或选择子（selector），可以接受参数，而且可能还有返回值。

由于 Objective-C 是 C 的超集，所以最好先理解 C 语言的函数调用方式。C 语言使用“静态绑定”（static binding），也就是说，在编译期就能确定运行时所应调用的函数。以下代码为例：


```c
#import <stdio.h>
void printHello() {
  printf("Hello, world \n" );
}

void printGoodbye() {
  printf("Goodbye, world\n");
}

void doTheThing(int type) {
  if (type == 0) {
    printHello();
  } else {
    printGoodbye();
  }
  return 0;
}

```

编译器在编译代码的时候就已经知道程序中用 printHello 与 printGoodbye 这个两个函数了，于是会直接生成调用这些函数的指令。而函数地址实际上是硬编码在指令之中的。若刚才的那段代码写成下面这样

```c
#import <stdio.h>
void printHello() {
  printf("Hello, world \n" );
}

void printGoodbye() {
  printf("Goodbye, world\n");
}

void doTheThing(int type) {
  void (*func)();
  if (type == 0) {
    func = printHello();
  } else {
    func = printGoodbye();
  }
  func();
  return 0;
}

```

这时候就使用“动态绑定”（dynamic binding）了，因为所要调用的的函数直到运行期才能确定。编译器在这种情况下生成的指令与刚才那个例子不同，第一个例子中，if 与 else 语句里都有函数调用指令。而在第二个例子中，只有一个函数调用指令，不过待调用的函数地址无法硬编码在指令中，而是要在运行期独取出来。

在 Objective-C 中，如果向某个对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所用的方法都是普通的 C 语言函数，然而对象收到消息之后，究竟该调用哪个方法完全取决与运行期决定，甚至可以在程序运行时改变，这些特性是的 Objective-C 成为一门真正的动态语言。

给对象发送消息可以这样来写:

```
id returnValue = [someObject messageName:parameter];

```

在本例中，someObject 叫做“接受者”（receiver）， messageName 叫做 “选择子” （selector）。选择子与参数结合起来叫做“消息”（message）。编译器看到此消息后，将其转换为一条标准的 C 语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做 objc_msgSend，其“原型”（prototype）如下：

```
id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);
```


objc_msgSend 函数会依据接受者与选择子的类型来调用适当的方法。为完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”（list of methods），如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，就沿着继承体系往上查找，等找到合适的方法之后再跳转。如果最终没有找到相符的方法，那会执行 “消息转发”（message forwarding）操作。

这么说来，想调用一个方法似乎需要很多步骤。所幸 objc_msgSend 会将匹配到结果缓存在“快速映射表”（fast map）里面，每一个类都有这样一块缓存，若稍后还是向该类发送与选择子相同的消息，那么执行起来就很快了。


总的来说，消息传递大致有以下几个步骤：

1. 系统首先找到消息的接收对象，然后通过对象的isa找到它的类。
2. 在它的类中查找method_list，是否有selector方法。
3. 没有则查找父类的method_list。
4. 找到对应的method，执行它的IMP。
5. 转发IMP的return值。


## 2、消息转发
当 OC 向某个对象发送了一条未知的消息时，他并不会马上报错，而是会经历几个步骤：

![](https://raw.githubusercontent.com/DullDevil/pics/master/base/method-forwarding.png)

### 1.动态方法解析(Method resolution)
首先调用所属类的的类方法`+resolveInstanceMrthod` 可以有机会为该未知消息新增一个处理方法，不过前提是我们已经实现了这个处理方法，我们可以通过 `class_addMethod` 函数动态的添加未知消息到类里，让原来没有处理这个消息的类具有处理这个消息的能力

### 2.备用接收者(Fast forwarding)
如果目标对象实现了`-forwardingTargetForSelector:`，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点

### 3.完整消息转发( Normal forwarding)
这一步是Runtime最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回nil，Runtime则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象。


这里贴一个SelectorSafe 的实现代码，其思路就是在完整消息转发( Normal forwarding)阶段，做了一个挽救操作，防止应用crash。

理论上应该是越早拦截成本越小，但是系统的一些方法也会用到消息的特性在动态方法解析(Method resolution)和备用接收者(Fast forwarding)阶段做一些操作，所以只能将挽救操作放在最后一步。

```objective_c
@interface _UnregSelObjectProxy : NSObject
+ (instancetype) sharedInstance;
@end

@implementation _UnregSelObjectProxy

+ (instancetype) sharedInstance{

    static _UnregSelObjectProxy *instance=nil;
    static dispatch_once_t once_token;
    dispatch_once(&once_token, ^{
        instance = [[_UnregSelObjectProxy alloc] init];
    });
    return instance;
}

+ (BOOL) resolveInstanceMethod:(SEL)selector {

    class_addMethod([self class], selector,(IMP)emptyMethodIMP,"v@:");
    return YES;
}

void* emptyMethodIMP(){
    return nil;
}

@end

@implementation NSObject (SelectorSafe)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        [self swizzleInstanceMethod:@selector(methodSignatureForSelector:) withNew:@selector(dd_methodSignatureForSelector:)];
        [self swizzleInstanceMethod:@selector(forwardInvocation:) withNew:@selector(dd_forwardInvocation:)];

    });
}


- (NSMethodSignature *)dd_methodSignatureForSelector:(SEL)sel{

    NSMethodSignature *sig;
    sig = [self dd_methodSignatureForSelector:sel];
    if (sig) {
        return sig;
    }

    sig = [[_UnregSelObjectProxy sharedInstance] dd_methodSignatureForSelector:sel];
    if (sig){
        return sig;
    }

    return nil;
}

- (void)dd_forwardInvocation:(NSInvocation *)anInvocation{
    [anInvocation invokeWithTarget:[_UnregSelObjectProxy sharedInstance] ];
}

@end
```
