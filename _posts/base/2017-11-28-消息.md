---
title: iOS 基础：消息
categories: [iOS 基础]
---

- TOC
{:toc}

## 发送消息
在对象上调用方法是 Objective-C 中经常使用的功能。用 Objective-C 的术语来说这叫做“传递消息”（pass a message）。消息有名称（name）或选择子（selector），可以接受参数，而且可能还有返回值。

由于 Objective-C 是 C 的超集，所以最好先理解 C 语言的函数调用方式。C 语言使用“静态绑定”（static binding），也就是说，在编译期就能确定运行时所应调用的函数。以下代码为例：


```c
#import <stdio.h>
void printHello() {
  printf("Hello, world \n" );
}

void printGoodbye() {
  printf("Goodbye, world\n");
}

void doTheThing(int type) {
  if (type == 0) {
    printHello();
  } else {
    printGoodbye();
  }
  return 0;
}

```

如果不考虑“内联”（inline），那么编译器在编译代码的时候就已经知道程序中用 printHello 与 printGoodbye 这个两个函数了，于是会直接生成调用这些函数的指令。而函数地址实际上是硬编码在指令之中的。若刚才的那段代码写成下面这样

```c
#import <stdio.h>
void printHello() {
  printf("Hello, world \n" );
}

void printGoodbye() {
  printf("Goodbye, world\n");
}

void doTheThing(int type) {
  void (*func)();
  if (type == 0) {
    func = printHello();
  } else {
    func = printGoodbye();
  }
  func();
  return 0;
}

```

这时候就使用“动态绑定”（dynamic binding）了，因为所要调用的的函数直到运行期才能确定。编译器在这种情况下生成的指令与刚才那个例子不同，第一个例子中，if 与 else 语句里都有函数调用指令。而在第二个例子中，只有一个函数调用指令，不过待调用的函数地址无法硬编码在指令中，而是要在运行期独取出来。

在 Objective-C 中，如果向某个对象传递消息，那就会使用动态绑定机制来决定需要调用的方法。在底层，所用的方法都是普通的 C 语言函数，然而对象收到消息之后，究竟该调用哪个方法完全取决与运行期决定，甚至可以在程序运行时改变，这些特性是的 Objective-C 成为一门真正的动态语言。

给对象发送消息可以这样来写:

```
id returnValue = [someObject messageName:parameter];

```

在本例中，someObject 叫做“接受者”（receiver）， messageName 叫做 “选择子” （selector）。选择子与参数结合起来叫做“消息”（message）。编译器看到此消息后，将其转换为一条标准的 C 语言函数调用，所调用的函数乃是消息传递机制中的核心函数，叫做 objc_msgSend，其“原型”（prototype）如下：

```
id returnValue = objc_msgSend(someObject,@selector(messageName:),parameter);
```


objc_msgSend 函数会依据接受者与选择子的类型来调用适当的方法。为完成此操作，该方法需要在接受者所属的类中搜寻其“方法列表”（list of methods），如果能找到与选择子名称相符的方法，就跳至其实现代码。若是找不到，就沿着继承体系往上查找，等找到合适的方法之后再跳转。如果最终没有找到相符的方法，那会执行 “消息转发”（message forwarding）操作。

这么说来，想调用一个方法似乎需要很多步骤。所幸 objc_msgSend 会将匹配到结果缓存在“快速映射表”（fast map）里面，每一个类都有这样一块缓存，若稍后还是向该类发送与选择子相同的消息，那么执行起来就很快了。


## 2、消息转发
当 OC 向某个对象发送了一条未知的消息时，他并不会马上报错，而是会经历几个步骤：

![](https://raw.githubusercontent.com/DullDevil/pics/master/base/method-forwarding.png)

### 1.动态方法解析(Method resolution)
首先调用所属类的的类方法`+resolveInstanceMrthod` 可以有机会为该未知消息新增一个处理方法，不过前提是我们已经实现了这个处理方法，我们可以通过 `class_addMethod` 函数动态的添加未知消息到类里，让原来没有处理这个消息的类具有处理这个消息的能力

### 2.备用接收者(Fast forwarding)
如果目标对象实现了`-forwardingTargetForSelector:`，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。 只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal Fowarding。 这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相对更快点

### 3.完整消息转发( Normal forwarding)
这一步是Runtime最后一次给你挽救的机会。首先它会发送`-methodSignatureForSelector:`消息获得函数的参数和返回值类型。如果`-methodSignatureForSelector:`返回nil，Runtime则会发出`-doesNotRecognizeSelector:`消息，程序这时也就挂掉了。如果返回了一个函数签名，Runtime就会创建一个`NSInvocation`对象并发送`-forwardInvocation:`消息给目标对象。


这里贴一个SelectorSafe 的实现代码，其思路就是在完整消息转发( Normal forwarding)阶段，做了一个挽救操作，防止应用crash。

理论上应该是越早拦截成本越小，但是系统的一些方法也会用到消息的特性在动态方法解析(Method resolution)和备用接收者(Fast forwarding)阶段做一些操作，所以只能将挽救操作放在最后一步。

```objective_c
@interface _UnregSelObjectProxy : NSObject
+ (instancetype) sharedInstance;
@end

@implementation _UnregSelObjectProxy

+ (instancetype) sharedInstance{

    static _UnregSelObjectProxy *instance=nil;
    static dispatch_once_t once_token;
    dispatch_once(&once_token, ^{
        instance = [[_UnregSelObjectProxy alloc] init];
    });
    return instance;
}

+ (BOOL) resolveInstanceMethod:(SEL)selector {

    class_addMethod([self class], selector,(IMP)emptyMethodIMP,"v@:");
    return YES;
}

void* emptyMethodIMP(){
    return nil;
}

@end

@implementation NSObject (SelectorSafe)

+ (void)load {
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        [self swizzleInstanceMethod:@selector(methodSignatureForSelector:) withNew:@selector(dd_methodSignatureForSelector:)];
        [self swizzleInstanceMethod:@selector(forwardInvocation:) withNew:@selector(dd_forwardInvocation:)];

    });
}


- (NSMethodSignature *)dd_methodSignatureForSelector:(SEL)sel{

    NSMethodSignature *sig;
    sig = [self dd_methodSignatureForSelector:sel];
    if (sig) {
        return sig;
    }

    sig = [[_UnregSelObjectProxy sharedInstance] dd_methodSignatureForSelector:sel];
    if (sig){
        return sig;
    }

    return nil;
}

- (void)dd_forwardInvocation:(NSInvocation *)anInvocation{
    [anInvocation invokeWithTarget:[_UnregSelObjectProxy sharedInstance] ];
}

@end
```
