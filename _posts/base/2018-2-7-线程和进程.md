---
title: iOS 基础：进程和线程
categories: [iOS 基础]
---

- TOC
{:toc}

## 一、进程和线程
### 1.什么是进程

进程是指在系统中正在运行的一个应用程序。每个进程之间是独立的，每个进程均运行在其专用且受保护的内存空间内。

比如同时打开QQ、Xcode，系统就会分别启动2个进程。通过“活动监视器”可以查看Mac系统中所开启的进程

### 2.什么是线程

1个进程要想执行任务，必须得有线程（每1个进程至少要有1条线程）

线程是进程的基本执行单元，一个进程（程序）的所有任务都在线程中执行


### 3.线程的串行

1个线程中任务的执行是串行的（注意这是在单一的线程中）。如果要在1个线程中执行多个任务，那么只能一个一个地按顺序执行这些任务

也就是说，在同一时间内，1个线程只能执行1个任务。比如在1个线程中下载3个文件（分别是文件A、文件B、文件C）

## 二、多线程

### 1.什么是多线程

1个进程中可以开启多条线程，每条线程可以并行（同时）执行不同的任务

进程 ->车间，线程->车间工人

多线程技术可以提高程序的执行效率

### 2.多线程的原理

同一时间，CPU只能处理1条线程，只有1条线程在工作（执行）
多线程并发（同时）执行，其实是CPU快速地在多条线程之间调度（切换）
如果CPU调度线程的时间足够快，就造成了多线程并发执行的假象
思考：如果线程非常非常多，会发生什么情况？
CPU会在N多线程之间调度，CPU会累死，消耗大量的CPU资源
每条线程被调度执行的频次会降低（线程的执行效率降低）

### 3.多线程的优缺点

多线程的优点
* 能适当提高程序的执行效率
* 能适当提高资源利用率（CPU、内存利用率）

多线程的缺点
* 开启线程需要占用一定的内存空间（默认情况下，主线程占用1M，子线程占用512KB），如果开启大量的线程，会占用大量的内存空间，降低程序的性能。
* 线程越多，CPU在调度线程上的开销就越大。
* 程序设计更加复杂：比如线程之间的通信、多线程的数据共享。


### 4.多线程在iOS开发中的应用

主线程:一个iOS程序运行后，默认会开启1条线程，称为“主线程”或“UI线程”

主线程的主要作用
* 显示\刷新UI界面
* 处理UI事件（比如点击事件、滚动事件、拖拽事件等）


主线程的使用注意:别将比较耗时的操作放到主线程中。耗时操作会卡住主线程，严重影响UI的流畅度，给用户一种“卡”的坏体验

## 三、线程安全

### 1.property的atomic
atomic的作用只是给getter和setter加了个锁，atomic只能保证代码进入getter或者setter函数内部时是安全的，一旦出了getter和setter，多线程安全只能靠程序员自己保障了。所以atomic属性和使用property的多线程安全并没什么直接的联系。另外，atomic由于加锁也会带来一些性能损耗，所以我们在编写iOS代码的时候，一般声明property为nonatomic，在需要做多线程安全的场景，自己去额外加锁做同步。

### 2.如何做到多线程安全
关键字是atomicity（原子性），只要做到原子性，小到一个primitive type变量的访问，大到一长段代码逻辑的执行，原子性能保证代码串行的执行，能保证代码执行到一半的时候，不会有另一个线程介入。

原子性是个相对的概念，它所针对的对象，粒度可大可小。

比如下段代码：

```objective_c
if (self.stringA.length >= 10) {
    NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];
}
```

是非原子性的。

但加锁以后：

```objective_c
//thread A
[_lock lock];
for (int i = 0; i < 100000; i ++) {
    if (i % 2 == 0) {
        self.stringA = @"a very long string";
    }
    else {
        self.stringA = @"string";
    }
    NSLog(@"Thread A: %@\n", self.stringA);
}
[_lock unlock];

//thread B
[_lock lock];
if (self.stringA.length >= 10) {
    NSString* subStr = [self.stringA substringWithRange:NSMakeRange(0, 10)];
}
[_lock unlock];

```

整段代码就具有原子性了，就可以认为是多线程安全了。

如何使用哪种锁？iOS给代码加锁的方式有很多种，常用的有：
* @synchronized(token)
* NSLock
* dispatch_semaphore_t
* OSSpinLock

这几种锁都可以带来原子性，性能的损耗从上至下依次更小。


### 3.Atomic Operations

除了各种锁之外，iOS上还有另一种办法来获取原子性，使用Atomic Operations，相比锁的损耗要小一个数量级左右，在一些追求高性能的第三方Framework代码里可以看到这些Atomic Operations的使用。这些atomic operation可以在/usr/include/libkern/OSAtomic.h中查到：

比如

```objective_c
_intA ++;
```
是非原子性的。

```objective_c
OSAtomicIncrement32(&(_intA));
```

是原子性的，多线程安全的。

Atomic Operation只能应用于32位或者64位的数据类型，在多线程使用NSString或者NSArray这类对象的场景，还是得使用锁。
